# Summary
# This reusable workflow handles building UE4SS with CMake, including setup of dependencies and uploading of artifacts.
name: "Build UE4SS with CMake"
permissions:
  contents: read
on:
  workflow_call:
    inputs:
      build-mode:
        description: 'Which UE4SS Mode to build (e.g., Game__Shipping__Win64)'
        type: string
        required: true
      commit-sha:
        description: 'Commit to build'
        type: string
        required: true
      should-upload-artifact:
        description: 'Should build output be uploaded as an artifact?'
        type: boolean
        default: false
      artifact-retention-days:
        description: 'How many days to retain artifacts'
        type: string
        default: '7'
defaults:
  run:
    shell: pwsh
jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.UEPSEUDO_PAT }}
          ref: ${{inputs.commit-sha}}

      # Calculate cache key based on CMakeLists and submodules
      - name: Calculate cache key
        id: cache_key
        run: |
          # Get all CMakeLists.txt and .cmake files and create a combined hash
          $files = Get-ChildItem -Path . -Include "CMakeLists.txt","*.cmake" -Recurse
          $combinedContent = ""
          foreach ($file in $files) {
            $combinedContent += (Get-FileHash $file.FullName).Hash
          }
          
          # Create a hash of the combined hashes using SHA256
          $stringAsStream = [System.IO.MemoryStream]::new()
          $writer = [System.IO.StreamWriter]::new($stringAsStream)
          $writer.write($combinedContent)
          $writer.Flush()
          $stringAsStream.Position = 0
          $cmakeHash = (Get-FileHash -InputStream $stringAsStream -Algorithm SHA256).Hash
          
          # Get submodule commits hash
          git submodule status > submodule_status.txt
          $submoduleHash = (Get-FileHash submodule_status.txt).Hash
          
          # Combine hashes for final cache key
          $combinedHash = "$cmakeHash-$submoduleHash"
          echo "hash=$combinedHash" >> $env:GITHUB_OUTPUT
          
          # Clean up temp file
          Remove-Item submodule_status.txt

      # Setup sccache for faster compilation
      - name: Setup sccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: sccache-${{ inputs.build-mode }}-${{ runner.os }}
          variant: sccache
          max-size: 2G

      # Use pre-installed VS instead of downloading
      - name: Setup MSVC Developer Command Prompt
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64
          vsversion: "2022"

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: 'latest'
          
      - name: Setup Ninja
        uses: seanmiddleditch/gha-setup-ninja@v5

      - name: Create build directory name
        id: build_dir
        run: |
          $mode = "${{inputs.build-mode}}"
          $buildDir = "build_cmake_$mode"
          echo "name=$buildDir" >> $env:GITHUB_OUTPUT

      # Cache the build directory for incremental builds
      - name: Cache CMake build directory
        uses: actions/cache@v4
        id: cache_build
        with:
          path: ${{ steps.build_dir.outputs.name }}
          key: cmake-build-${{ inputs.build-mode }}-${{ steps.cache_key.outputs.hash }}-${{ github.run_number }}
          restore-keys: |
            cmake-build-${{ inputs.build-mode }}-${{ steps.cache_key.outputs.hash }}-

      # Configure CMake (only if needed)
      - name: Configure CMake
        run: |
          $needs_reconfigure = $false
          
          if ("${{ steps.cache_build.outputs.cache-hit }}" -ne "true") {
            Write-Host "Cache miss - full configure needed"
            $needs_reconfigure = $true
          } elseif (-not (Test-Path "${{ steps.build_dir.outputs.name }}/CMakeCache.txt")) {
            Write-Host "No CMakeCache.txt - full configure needed"
            $needs_reconfigure = $true
          }
          
          if ($needs_reconfigure) {
            cmake -B ${{ steps.build_dir.outputs.name }} `
              -G Ninja `
              -DCMAKE_BUILD_TYPE="${{inputs.build-mode}}" `
              -DCMAKE_C_COMPILER=cl `
              -DCMAKE_CXX_COMPILER=cl `
              -DCMAKE_C_COMPILER_LAUNCHER=sccache `
              -DCMAKE_CXX_COMPILER_LAUNCHER=sccache `
              -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
          } else {
            Write-Host "Using cached configuration - incremental build"
            # Just run cmake to ensure cache is valid
            cmake ${{ steps.build_dir.outputs.name }}
          }

      # Build ALL targets (will be incremental if cache hit)
      - name: Build All Targets
        run: |
          Write-Host "Building all targets..."
          # Build everything - this will build UE4SS, proxy, all mods, etc.
          cmake --build ${{ steps.build_dir.outputs.name }}

      # Collect all DLLs and PDBs automatically
      - name: Calculate Files For Artifact Inclusion
        id: calc-files-artifact
        if: ${{inputs.should-upload-artifact == true}}
        run: |
          $artifact_dir = New-Item -Path '${{runner.temp}}/ue4ss_artifacts/' -ItemType Directory -Force
          $buildDir = "${{ steps.build_dir.outputs.name }}"
          
          # System/Windows DLLs to exclude (add more as needed)
          $excludedDlls = @(
            "kernel32.dll", "user32.dll", "advapi32.dll", "shell32.dll",
            "ole32.dll", "oleaut32.dll", "msvcrt.dll", "comctl32.dll",
            "gdi32.dll", "rpcrt4.dll", "ws2_32.dll", "winmm.dll"
          )
          
          Write-Host "Collecting build artifacts from $buildDir..."
          
          # Find all DLLs in the build directory
          $dllFiles = Get-ChildItem -Path $buildDir -Recurse -Filter "*.dll" -ErrorAction SilentlyContinue
          $pdbFiles = Get-ChildItem -Path $buildDir -Recurse -Filter "*.pdb" -ErrorAction SilentlyContinue
          
          # Copy DLLs (excluding system DLLs)
          foreach ($dll in $dllFiles) {
            if ($excludedDlls -notcontains $dll.Name.ToLower()) {
              Write-Host "✓ Found DLL: $($dll.Name) from $($dll.Directory.Name)"
              Copy-Item $dll.FullName -Destination $artifact_dir -Force
            } else {
              Write-Host "⊘ Skipping system DLL: $($dll.Name)"
            }
          }
          
          # Copy all PDBs (debug symbols)
          foreach ($pdb in $pdbFiles) {
            Write-Host "✓ Found PDB: $($pdb.Name)"
            Copy-Item $pdb.FullName -Destination $artifact_dir -Force
          }
          
          # Also look for any .exe files that might be built
          $exeFiles = Get-ChildItem -Path $buildDir -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue
          foreach ($exe in $exeFiles) {
            Write-Host "✓ Found EXE: $($exe.Name)"
            Copy-Item $exe.FullName -Destination $artifact_dir -Force
          }
          
          # Special handling for specific required files
          $requiredFiles = @("dwmapi.dll", "UE4SS.dll")
          foreach ($required in $requiredFiles) {
            $found = Get-ChildItem -Path $artifact_dir -Filter $required -ErrorAction SilentlyContinue
            if (-not $found) {
              # Try to find it in the source tree (for proxy dll)
              $sourceFile = Get-ChildItem -Path . -Recurse -Filter $required -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($sourceFile) {
                Write-Host "✓ Found required file in source: $required"
                Copy-Item $sourceFile.FullName -Destination $artifact_dir -Force
              } else {
                Write-Host "⚠ Warning: Required file $required not found anywhere!"
              }
            }
          }
          
          # Summary of collected artifacts
          Write-Host "`n========== Artifact Summary =========="
          $artifacts = Get-ChildItem -Path $artifact_dir
          Write-Host "Total files collected: $($artifacts.Count)"
          
          # Group by extension
          $artifacts | Group-Object Extension | ForEach-Object {
            Write-Host "$($_.Name) files: $($_.Count)"
            $_.Group | ForEach-Object { Write-Host "  - $($_.Name)" }
          }
          
          echo "artifact_dir=$artifact_dir" >> $env:GITHUB_OUTPUT

      - name: Upload a Build Artifact
        if: ${{inputs.should-upload-artifact == true}}
        uses: actions/upload-artifact@v4
        with:
          name: CMAKE-${{inputs.build-mode}}
          path: ${{ steps.calc-files-artifact.outputs.artifact_dir }}
          retention-days: ${{ inputs.artifact-retention-days }}
          overwrite: true